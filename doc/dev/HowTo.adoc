ifndef::imagesdir[:imagesdir: imgs]

== Development FAQ
:toc:

=== How to overidde a Sirius Web service

In some cases you will need to override service to provided by Sirius Web.
To do so, create a custom implementation of the service and use the annotation `org.eclipse.papyrus.web.sirius.contributions.ServiceOverride`.
You need to specify the overridden service in the annotation.
This information is only here to keep tracks.
It is important when bumping _sirius component_ version in order to keeps tracks of the changes applied to the overridden services.

=== How to find/use all concepts model

In order to populate UML tab of Details panel with each UML concept content, we created a single model that contains all UML concepts. This model can be uploaded inside Papyrus web (via `Upload Model` from Explorer view). The UML file is located inside the following directory:
```
<papyrus-web repo>/backend/papyrus-web-application/src/test/resources/models/all-concepts/
```
In order to locate each concept inside the model, we defined an index giving the path of each UML concept inside this model. This file, `all-concepts.txt` is located inside the same above directory. For instance, the concept `ComponentRealization` has the following entry in the index:
```
ComponentRealization -> Model::Activity::CollaborationUse::ComponentRealization
```
This indicates that this concept can be found inside `CollaborationUse` which is a child of `Activity`.


=== How to modify the predefined language list of the lanugage expression widget

OpaqueExpressions, OpaqueActions, OpaqueBehaviors and FunctionBehaviors UML elements have a special property `language` that can be edited in the UML tab of the Details panel with a dedicated widget. This widget allows to choose a language among a predefined list. At the moment, this list of language names is hardcoded in the backend code. This is list is located in:

```
org.eclipse.papyrus.web.custom.widgets.languageexpression.LanguageExpressionComponent.getPredefinedLanguages()
```

Here its definition:

[source, java]
-----
  private List<String> getPredefinedLanguages() {
      return List.of("C", "C++", "JAVA", "Natural Language", "OCL");
  }
-----

=== How to use Shared Descriptions?

==== What are shared elements?

Shared elements are a reuse mechanism we use to avoid the duplication of NodeDescription in our DSL View. They are defined in a `SHARED_DESCRIPTIONS` NodeDescription, and are reused by all the description that can contain them.

This mechanism ensures that a NodeDescription is defined at a single place, which eases the maintenance and evolution of the DSL View. 

Note that some diagrams contain top-level NodeDescription in addition to shared elements to represent elements on the diagram background. These top-level NodeDescription typically cannot be reused from the `SHARED_DESCRIPTIONS` because their semantic candidate expression is different.

==== When should I use a shared element?

The rules below cover the use cases where a shared element should be used to avoid code duplication.
1. A shared element is reused by **at least** two other elements (as child node or border node). Note that being reused by the diagram itself doesn't count.
2. A non-shared element cannot be reused by another element
3. A shared element is suffixed with `_SHARED` and stored in a common `SHARED_DESCRIPTIONS` NodeDescription at the root of the DSL view.
4. The `SHARED_DESCRIPTIONS` NodeDescription targets the `UML#Element` metaclass as its semantic domain.
5. The `SHARED_DESCRIPTIONS` NodeDescription doesn't contain tools.
6. The `SHARED_DESCRIPTIONS` NodeDescription has the following semantic candidate expression: `aql:Sequence{}` to make sure it is never displayed.
7. Elements that are used in a single location (e.g. elements inside a Package that cannot be represented anywhere else) should be defined inside their containing element (and not the shared description)
  - If they are reused in another location (e.g. elements inside a Package and a Profile) they should be defined as shared elements.
8. Shared elements' `semanticCandidateExpression` should never use `QueryBuilder#getAllReachable`. It should instead contain a semantic expression based on the container, or a call to a service if the semantic candidate expression is complex.

*These rules are validated during the build of Papyrus Web.*

==== Tooling around shared elements

- Use `AbstractRepresentationDescriptionBuilder#createSharedDescription` to create a shared description for a given diagram. This method takes care of the naming of the shared description, setting its semantic domain, and its semantic candidate expression (rules 4, 5, and 6).
- Use `AbstractRepresentationDescriptionBuilder#createCommentDescriptionInNodeDescription` and `AbstractRepresentationBuilder#createConstraintDescriptionInNodeDescription` to create constraint and comments in the shared description passed as a parameter (rules 3, 8).
  - Comments and constraints can be represented in various container in most diagrams. These methods provide a common implementation that can be reused as is in new diagrams.
- Use `IdBuilder.getSpecializedDomainNodeName(eClass, AbstractRepresentationDescriptionBuilder.SHARED_SUFFIX)` to create a node description with the `_SHARED` suffix (rule 3).
- Use `sharedDescriptionNode.getChildrenDescriptions().add(myNodeDescription)` to add a NodeDescription to the `SHARED_DESCRIPTIONS` element. This NodeDescription can be created with the regular creation APIs such as `org.eclipse.papyrus.web.application.representations.uml.AbstractRepresentationDescriptionBuilder.newNodeBuilder(EClass, NodeStyleDescription)`. In this case it's the user's responsibility to ensure that the NodeDescription complies with the rules defined above. 

=== Pages management in Details panel

This section focus upon the API that can be used to manage pages inside the Details panel of Papyrus web.

==== Main API

The entry point to be able to manage pages in the Details panel is:

[source, java]
--
org.eclipse.sirius.components.collaborative.forms.api.IFormPostProcessor
--

The way to follow is to create a Spring service that implements this API and override the following method:

[source, java]
--
Form postProcess(Form form, VariableManager variableManager)
--

This method will receive an immutable _Form_ instance that represents the Details panel and variables available at this point. 
Therefore, it is possible to filter/sort/organize pages retrieved from that original _Form_ and return the desired presentation as a *new* _Form_ instance.

==== Papyrus implementation

The Papyrus implementation of this API can be found in the following class:

[source, java]
--
org.eclipse.papyrus.web.application.properties.services.PapyrusDetailsPostProcessor
--

This implementation sorts pages as it was designed in papyrus desktop: starts with the `UML` tab followed by tabs `Comments` and `Profile` and ends with `Advanced` one.


=== How can I test my diagrams?
Papyrus Web provides a _test framework_ to ease the development of test suites for your diagrams. The framework is a generic testing infrastructure defined at the boundaries of Papyrus Web's _backend_: it simulates the invocation of tools (Node Creation, Edge Creation, etc) via the GraphQL API, and checks the data exposed to the frontend. This approach allows to finely check graphical and semantic data, but cannot perform graphical-level tests through the user interface (this can be done with end-to-end integration tests like Cypress).

The Papyrus Web test framework is defined in the `papyrus-web-application` module (in the `src/tests` directory), in the packages prefixed with _tool_:

image::test-framework-architecture.png[Test Framework Architecture,400, align="center"]

- *org.eclipse.papyrus.web.application.tools.test*: the abstract test classes that can be extended by the specifier to test specific tools. These classes provide a common ground to implement tests, and are designed to allow parameterization of concrete implementations.
- *org.eclipse.papyrus.web.application.tools.checker*: the generic checkers used by the tests to verify the diagram and the semantic model. These checkers operate at the semantic or graphical level, and can be grouped in a `CombinedChecker`.
-  *org.eclipse.papyrus.web.application.tools.utils*: a set of utility classes that provide common behavior and data for the implementation of test cases. For example, this package contains a default implementation of the `MappingTypes` class, that allows to compute the mapping type associated to a given UML type.

Implementations of the test framework for a specific diagram should follow the same naming/packaging conventions. For example, the Use Case Diagram implementation is defined in the following packages:

- *org.eclipse.papyrus.web.application.tools.usecase*: the concrete implementation of the abstract test classes provided by the framework. These classes allow to test node creation, edge creation, etc in the context of the Use Case Diagram.
- *org.eclipse.papyrus.web.application.tools.usecase.utils*: utility classes specific to the Use Case Diagram. For example, the `UCDMappingTypes` extends `MappingType` to support Use Case specific mappings.